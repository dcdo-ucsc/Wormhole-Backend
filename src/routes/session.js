const express = require('express');
const path = require('path');
const fs = require('fs');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const QRCode = require('qrcode');
const router = express.Router();

const {
  SESSION_PATH,
  JWT_DOWNLOAD_AUTH_EXPIRY,
} = require('../configs/serverConfig');
const {
  isValidSessionIdFormat,
  isValidSessionEntry,
  isValidUUIDv4,
} = require('../helpers/sessionValidation');
const agenda = require('../utils/agenda');
const Session = require('../models/Session');

/**
 * Endpoint to create a new session, scheduled for deletion after expiry time is reached
 *
 * */
router.post('/create', async (req, res) => {
  const userId = req.cookies.userId;
  const deletionTime = Date.now() + Number(req.body.expiry);

  // Validate uuidv4 user format
  if (!isValidUUIDv4(res, userId)) return;

  // Create entry in MongoDB
  const newSession = new Session({
    userId,
    deletionTime,
    files: [],
  });

  // SessionId is generated by MongoDB (using ObjectId)
  const sessionId = newSession._id.toString();
  const sessionDir = path.join(SESSION_PATH, sessionId);
  newSession.directory = sessionDir; // Add the directory to the session entry
  fs.mkdirSync(sessionDir); // Create a directory for the session within session folder

  // If password is provided, hash it and save to db
  if (req.body.password && req.body.password !== '') {
    newSession.password = await bcrypt.hash(req.body.password, 10);
  }

  // Save the session entry to MongoDB
  await newSession.save();

  // Schedule deletion of session
  const expiresIn = Math.floor((deletionTime - Date.now()) / 1000);
  try {
    agenda.schedule(deletionTime, 'delete session', {
      sessionDir,
      sessionId,
    });
  } catch (err) {
    console.error('Error scheduling deletion: ', err);
    return res.status(500).json({ error: 'Error scheduling deletion' });
  }

  // Create an owner access token for the session
  // owner accessToken stores the `sessionId` and `userId`
  const accessToken = jwt.sign({ sessionId, userId }, process.env.SECRET_KEY, {
    expiresIn,
  });

  /* Set cookie for the session Owner
    name: token_owner_<sessionId>
    val : accessToken
  */
  res.cookie(`token_owner_${sessionId}`, accessToken, {
    maxAge: req.body.expiry,
  });

  // Respond with sessionId & deletion time
  res.json({
    sessionId,
    deletionTime,
  });
});

/**
 * Fetches the session data for the given session ID
 * Returns:
 *  - QR Code data URL
 *  - Deletion time
 * */
router.get('/data/:sessionId', async (req, res) => {
  const { sessionId } = req.params;

  try {
    // Fetch session from the database using the session ID
    // const sessionData = await Session.findById(sessionId);

    // Retrieve the session from the database
    const sessionData = await isValidSessionEntry(res, sessionId);
    if (!sessionData) return;

    // Check if the session exists
    if (!sessionData) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // Generate the QR code URL for this session
    const sessionUrl = `${req.protocol}://${req.get(
      'host'
    )}/api/session/${sessionId}`;

    // Generate a QR code
    QRCode.toDataURL(sessionUrl, (err, qrCodeDataURL) => {
      if (err) {
        console.error('Error generating QR code:', err);
        return res.status(500).json({ error: 'Error generating QR code' });
      }

      const deletionTime = sessionData.deletionTime;

      // Respond with session info, including QR code data URL and calculated deletion time
      res.json({
        sessionId: sessionData._id,
        qrCodeDataURL,
        deletionTime,
      });
    });
  } catch (error) {
    console.error('Error fetching session data:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/** Join Page Authentication
 *
 * The user will be given a token if they enter the correct password.
 * This should only be called if user isn't the owner of the session.
 *
 */
router.post('/auth', async (req, res) => {
  const sessionId = req.body.sessionId;
  if (!isValidSessionIdFormat(res, sessionId)) return;

  // Retrieve the session from the database
  const session = await isValidSessionEntry(res, sessionId);
  if (!session) return;

  // check if session is protected by a password
  if (session.password != null) {
    // check if password is provided
    if (req.body.password == null) {
      // if password is not provided
      return res.status(401).json({
        error: "You don't have permission to access this file on this server.",
      });
    }
    // check if password is correct
    if (!(await bcrypt.compare(req.body.password, session.password))) {
      return res.status(401).json({
        error: 'Invalid password',
      });
    }
  }

  // Create an access token for the user
  // user accessToken stores ONLY the `sessionId`
  const accessToken = jwt.sign({ sessionId }, process.env.SECRET_KEY, {
    expiresIn: JWT_DOWNLOAD_AUTH_EXPIRY,
  });

  // Calculate remaining time for the session to be deleted used for cookie maxAge
  const expiresIn = Math.floor(session.deletionTime - Date.now());

  /* Set cookie for the user
     name: token_user_<sessionId>
     val : accessToken
  */
  res.cookie(`token_user_${sessionId}`, accessToken, {
    maxAge: expiresIn,
  });

  res.status(200).json({ Success: 'Access granted' });
});

/**
 * Retrieve the file names in the session for file preview
 *
 */
router.get('/getFileNames/:sessionId', async (req, res) => {
  const { sessionId } = req.params;

  // Retrieve the session from the database
  const session = await Session.findById(sessionId);

  if (!session) {
    return res.status(404).json({ error: 'Session not found' });
  }

  // check if there are files in the session
  if (session.files.length === 0) {
    return res.status(404).json({
      error: 'No files found in this session',
    });
  }

  // get all file names from the DB
  const fileNames = session.files.map((file) => file.originalName);

  res.json(fileNames);
});

module.exports = router;
