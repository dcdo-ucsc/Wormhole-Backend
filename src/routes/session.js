const express = require("express");
const path = require("path");
const fs = require("fs");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const agenda = require("../utils/agenda");
const { SESSION_PATH, JWT_DOWNLOAD_AUTH_EXPIRY } = require("../configs/serverConfig");
const {
  isValidSessionIdFormat,
  isValidSessionEntry,
  isValidUUIDv4,
} = require("../helpers/sessionValidation");
const { authenticateToken } = require("../middlewares/sessionMiddleware");

const Session = require("../models/Session");

const router = express.Router();

/** Endpoint to create a new session, scheduled for deletion after a certain time
 *
 *  @name POST /api/session
 *
 * */
router.post("/create", async (req, res) => {
  const userId = req.body.userId;

  // Validate uuidv4 user format
  if (!isValidUUIDv4(res, userId)) return;

  // create entry in MongoDB
  const newSession = new Session({
    userId,
    files: [],
  });

  // sessionId is generated by MongoDB (using ObjectId)
  const sessionId = newSession._id.toString();
  const sessionDir = path.join(SESSION_PATH, sessionId);
  newSession.directory = sessionDir; // save to db
  fs.mkdirSync(sessionDir); // Create a directory for the session

  // if password is provided, hash it and save to db
  if (req.body.password && req.body.password !== "") {
    newSession.password = await bcrypt.hash(req.body.password, 10);
  }

  // Save the session to MongoDB
  await newSession.save();

  // schedule deletion of session
  const deletionTime = Date.now() + Number(req.body.expiry);
  const expiresIn = Math.floor((deletionTime - Date.now()) / 1000);
  try {
    agenda.schedule(deletionTime, "delete session", {
      sessionDir,
      sessionId,
    });
  } catch (err) {
    console.error("Error scheduling deletion: ", err);
    return res.status(500).json({ error: "Error scheduling deletion" });
  }

  const accessToken = jwt.sign({ sessionId, userId }, process.env.SECRET_KEY, {
    expiresIn,
  });
  console.log("Session created.");

  res.json({ sessionId, accessToken });
});

/**
 * Link for QR code. When the user creates the session, the front-end
 * should create the link for the QR code given the sessionId from sessionCreate.
 *
 * returns the sessionId & password status
 */
router.get("/:sessionId", async (req, res) => {
  const sessionId = req.params.sessionId;

  if (!isValidSessionIdFormat(res, sessionId)) return;

  const session = await isValidSessionEntry(res, sessionId);
  if (!session) return;

  res.json({ sessionId, password: session.password != null });
});

/**
 * The user will be given a token if they enter the correct password.
 * This should only be called if user isn't the owner of the session.
 *
 * check password
 * send 200 res & send auth token
 */
router.post("/auth", async (req, res) => {
  // const userId = req.body.userId;
  const sessionId = req.body.sessionId;

  // if (!isValidUUIDv4(res, userId)) return;
  if (!isValidSessionIdFormat(res, sessionId)) return;

  const session = await isValidSessionEntry(res, sessionId);
  if (!session) return;

  // check if session is protected by a password
  if (session.password != null) {
    // check if the user has provided a password
    if (req.body.password == null) {
      return res.status(401).json({
        error: "You don't have permission to access this file on this server.",
      });
    }
  }

  // check if password is correct
  if (!(await bcrypt.compare(req.body.password, session.password))) {
    return res.status(401).json({
      error: "Invalid password",
    });
  }

  const accessToken = jwt.sign({ sessionId }, process.env.SECRET_KEY, {
    expiresIn: JWT_DOWNLOAD_AUTH_EXPIRY,
  });

  res.json({ accessToken });
});

/**
 * Retrieve the files associated with the session
 *
 */
router.get("/getFiles", authenticateToken, async (req, res) => {
  const sessionId = req.payload.sessionId;

  // Retrieve the session from the database
  const session = await Session.findById(sessionId);

  if (!session) {
    return res.status(404).json({ error: "Session not found" });
  }

  // check if there are files in the session
  if (session.files.length === 0) {
    return res.status(404).json({
      error: "No files found in this session",
    });
  }

  // Send the files associated with the session back to the client
  res.json(session.files);
});

module.exports = router;
